# Домашнее задание к занятию 3.1 «Прототип массива, функции высшего порядка» 

## Задача №1. Ускорение долгих вычислений

Паша — разработчик из компании “Тындекс” встретился с такой проблемой, 
что иногда функция может считать результат очень долго, даже когда ей 
передавались одинаковые параметры, ведь она каждый раз пересчитывает 
результат. Создайте функцию, которая сможет “запоминать” 
результаты другой функции, которую ей передают в качестве аргумента. 
Для того, чтобы запомненные результаты не занимали всю память, 
сделайте массив запомненных результатов ограниченным: когда элементов 
становится больше 10, то самый старый результат удаляется, а новый -- добавляется.

### Процесс реализации

#### 1. sleep 
Реализуйте функцию, эмулирующую продолжительную работу. Так как в JavaScript отсутствует стандартный механизм приостановки выполнения кода на определённый промежуток времени, а с асинхронным кодом вы ещё не знакомы, то реализуйте искуственное замедление любого кода:
```javascript
function sleep(milliseconds) 
{
  let e = new Date().getTime() + milliseconds;
  while (new Date().getTime() <= e) {}
}
```

#### 2. sum
Реализуйте функцию, которая сможет работать с произвольным количеством аргументов. Например это может быть суммирование всех переданных чисел. Так же для эмуляции длительного выполнения функции добавьте вызов реализованного замедления:
```javascript
function sum(...args) {
  // Замедление на половину секунды.
  sleep(500); // Можно использовать другое значение замедления.
  return args.reduce((sum, arg) => {
    return sum += +arg;
  }, 0);
}
```

#### 3. compareArrays
Создайте вспомогательную функцию *compareArrays( arr1, arr2 )*, которая с помощью функции высшего порядка будет сравнивать значения двух массивов. Если массивы имеют одинаковые значения на одинаковых индексах, *compareArrays* должна выдавать true (иначе false). Используйте метод `every` для сравнения элементов одного массива с соответствующими элементами другого массива.

Пример вызова

```javascript
compareArrays([8, 9], [6]); // false, разные значения
compareArrays([8, 9, 5, 4], [8, 9, 5, 4, 8, 3, 5]); // false, разные значения
compareArrays([9, 2, 4, 8, 2], [9, 2, 4]); // false, разные значения
compareArrays([1, 2, 3], [2, 3, 1]); // false, разные индексы, хотя и одинаковые значения
compareArrays([8, 1, 2], [8, 1, 2]); // true
```
#### 4. memorize
Создайте функцию memorize(fn, limit), у которой *fn* - функция, 
которая производит вычисления, *limit* - ограничение по количеству результатов.

**1. Вызов результата**

Функция *memorize* должна возвращать **функцию**. В полученную функцию мы 
будем передавать аргументы так, как могли бы делать это с *fn*: 

```javascript
const mSum = memorize(sum, 5); // 5 результатов может хранится в памяти

// Вызов этих функций даёт один и тот же результат
sum(3, 4); // 7
/* 
  разница только в том, что mSum запоминает результат (7)
  и повторно не делает вычисления
 */
mSum(3, 4); // 7
```
**Предусмотрите возможность передачи произвольного количества аргументов!**

**2. Внутренняя память**

Объявите внутри *memorize* массив *results*, который будет хранить
историю вызовов возвращаемой *memorize* функции (в примере выше это *mSum*).
Каждый элемент массива *results* - объект с двумя свойствами:

```
{
  args, // массив аргументов, с которыми была вызывана функция
  result // результат работы
}
```

Для примера, *mSum( 3, 4 )* поместит в *results* такой объект:

```
{
  args: [3, 4],
  result: 7 // сумма 3 и 4
}
```

**3. Работа возвращаемой функции**

Функция, которую возвращает *memorize* в качестве результата работы,
выполняет следующую последовательность действий:

**1. Поиск**
 
С помощью функции `find` ищет в массиве *results*, сделанные вызов с аргументами, которые соответсвуют
аргументам, с которыми была вызвана возвращаемая *memorize* функция.

Например, для вызова *mSum* таким образом:

```javascript
const mSum = memorize(sum, 2);
mSum(3, 4); // 7
mSum(1, 3); // 4
```

*memory* будет выглядеть так:

```
[
    {
        args: [3, 4],
        result: 7
    },
    {
        args: [1, 3],
        result: 4
    }
]
``` 

После повторного вызова *mSum(3, 4)* необходимо найти запись, 
которая «помнит» о том, что ранее был вызов с этими аргументами, то есть вот эту:

```
{
  args: [1, 3],
  result: 4
}
```

Для поиска нужного значения используйте функцию *compareArrays*, написанную
вами ранее.

**2. Вычисление**

1. Если история о вызове функции *fn* найдена, то функция должна вернуть свойство
*result* найденного объекта.
2. В ином случае, необходимо:
    1. Вычислить результат *fn* с переданными аргументами.
    2. Добавить запись о вызове *fn* в *memory*.
    3. При количестве элементов *memory* более *limit* удалить лишнее.
    4. Вернуть результат *fn* с переданными аргументами.

#### 5. minitestCase
Реализуйте функцию, которая сможет тестировать сколькость работы вашей функции `memorize`. Ваша функция `minitestCase` должна принимать функцию `testFunction`, которая будет вызываться с разными аргументами. Создайте массив, содержащий массивы аргументов, например ` [ [1,2,3], [1,2], [1,2,3], [1,2], [9,5,2,4] ]`. Обязательно добавьте повторяющиеся и не повторяющиеся массивы чисел (которые будут аргументами). Вызовите метод `forEach`, в котором вызывайте вашу тестируемую функцию с перебираемыми аргументами.

#### 6. testCase и memorizeTestCase
Реализованная функция `minitestCase` будет вызываться всего несколько раз (5 раз с приведённым массивом). Этого недостаточно, для достаточно точного измерения затраченного времени. Для того, что бы проверить работу в реалиных условиях приготовьте функцию, которая будет замерять затраченное на вычисление время.
1. С помощью метода `console.time` запустите счётчик процессорного времени (метод принимает строку, по которой будет идентифицировать счётчик).
2. Создайте цикл, который выполняйте много раз (например 100), в котором вызывайте функцию `minitestCase`. Таким образом увеличивая количество вычислений во много раз (например в 100). Для тестирования передавайте обычную функцию `sum` (которая должна работать с задержкой).
3. В конце цикла остановите счётчик процессорного времени с помощью `console.timeEnd` (передав ту же строку, что и при запуске).
4. Реализуйте функцию `memorizeTestCase` в которой проделывайте тоже самое, только тестируйте оптимизированную функцию. Тоесть результат функции `memorize`.
5. Запустите функции `testCase` и `memorizeTestCase`. Для замера времени выполнения вычислений.
6. Сделайте выводы об оптимизации вычислений.
7. Уберите из функции `sum` задержку. Снова запустите функции-тесты и сделайте выводы о работе вашего кода.
8. Результаты вызовов напишите комментариями в коде или сообщением в личном кабинете.
    
### Критерии выполнения

1. Добавьте внутрь передаваемой функции *fn* вывод в консоль системной
информации о том, что функция вызвана не из памяти.
2. Добавьте внутрь *memorize* вывод в консоль о том, что результат берётся из
памяти.
3. Убедитесь на основе вывода в консоль, что параметр *limit* работает корректно.
4. Используйте циклы, только в запуске измерительных тестов. В остальных случаях используйте функции высшего порядка.

## Требования для выполнения домашней работы

* браузер;
* редактор кода, например [Sublime][1] или [Visual Studio Code][2];
* аккаунт на [GitHub][0] ([инструкция по регистрации на GitHub][3]);
* система контроля версий [Git][4], установленная локально ([инструкция по установке Git][5]).

## Начало работ

1. Создать репозиторий на [GitHub][0]. Параметры создаваемого репозитория:
* Repository name: `bjs-homeworks`;
* Access level: Public;
* Initialize this repository with a README: No;
* Add .gitignore: None;
* Add a license: None;
После нажатия на кнопку `Create repository` вы будете переведены на страницу вновь созданного репозитория.
URL адрес текущей страницы будет являться URL адресом вашего репозитория.
Пример URL адреса репозитория: `https://github.com/username/bjs-homeworks`, где `username` - имя вашего профиля GitHub, `bjs-homeworks` - название репозитория. Далее по тексту адрес вашего репозитория будет иметь обозначение: `%repo-url%`.
2. Создать директорию на вашем компьютере, в которой вы планируете выполнять домашние задания.
3. Открыть созданную директорию с помощью терминала или командной строки вашей операционной системы.
4. Клонировать репозиторий с домашними заданиями с помощью команды `git clone https://github.com/netology-code/bjs-homeworks` в открывшемся терминале или командной строке.
5. Перейти в директорию склонированного репозитория `cd ./bjs-homeworks`.
6. Добавить репозиторий в проект `git remote add homeworks %repo-url%`, где `%repo-url%` — адрес созданного репозитория.

## Решение задач
1. Перейти в папку задания, например, для первого задания `cd ./array-proto-hocs`.
2. Открыть файл `main.js` в вашем редакторе кода и выполнить задание.
3. Открыть файл `index.html` в вашем браузере и с помощью консоли DevTools убедиться в правильности выводимых результатов.
4. Добавить файл `main.js` в индекс git с помощью команды `git add %file-path%`, где %file-path% - путь до целевого файла, например, для первого задания `git add array-proto-hocs/main.js`.
5. Сделать коммит используя команду `git commit -m '%comment%'`, где %comment% - это произвольный комментарий к вашему коммиту, например, для первого задания 'first commit array-proto-hocs'.
6. Опубликовать код в репозиторий homeworks с помощью команды `git push -u homeworks master`.
7. Прислать ссылку на репозиторий через личный кабинет на сайте [Нетологии][6].

[0]: https://github.com/
[1]: https://www.sublimetext.com/
[2]: https://code.visualstudio.com/
[3]: https://github.com/netology-code/guides/blob/master/git/github.md
[4]: https://git-scm.com/
[5]: https://github.com/netology-code/guides/blob/master/git/REAMDE.md
[6]: https://netology.ru/

*Никаких файлов прикреплять не нужно.*

Все задачи обязательны к выполнению для получения зачета. Присылать на проверку можно каждую задачу по отдельности или все задачи вместе. Во время проверки по частям ваша домашняя работа будет со статусом "На доработке".

Любые вопросы по решению задач задавайте в Slack-канале.
